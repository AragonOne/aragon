import React from 'react'
import { styled } from '@aragon/ui'
import { clamp, lerp } from '../../math-utils'
import { noop } from '../../utils'
import AppLoadingProgressBar from './AppLoadingProgressBar'

const LOADING_START = 25 // Start loading indicator at 25%
const LOADING_END = 100
const LOADING_FUDGE_LIMIT = 75 // Limit arbitrary incremental movement of loading incator to 75%

// See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe for details about sandbox
// `sandbox` works like a whitelist: by default, almost every functionality is restricted.
const SANDBOX = [
  // Allows new browsing contexts (e.g. new windows or tabs) generated by the
  // iframe to escape the sandbox restrictions. Otherwise, new contexts would
  // share the same restrictions as their originating iframe (in our case, the
  // new contexts would only have the ability to run JavaScript).
  'allow-popups-to-escape-sandbox',

  // Gotta run 'em all!
  'allow-scripts',

  // Note that we haven't enabled:
  //   - 'allow-same-origin':
  //       The most important security setting: leaving this disabled lets the
  //       iframe be considered as coming from a unique, orphan origin. This
  //       means that the page won't have access to any cookies, local/session
  //       storage, or access to open pages (e.g. the parent window, this Dapp).
  //
  //       However, this does force some restrictions:
  //         - `window.postMessage()` must use `*` as an origin to communicate
  //           with this iframe
  //         - React devtools can't be hooked in from the browser, so you have
  //           to use the native `react-devtools` electron app for debugging
  //
  //  - 'allow-top-navigation':
  //       Leaving this disabled disallows the iframe from navigating the
  //       Dapp's context (e.g. to a malicious page)
].join(' ')

class AppIFrame extends React.Component {
  state = {
    loadProgress: 0,
  }
  componentWillMount() {
    if (this.props.src) {
      this.startProgress()
    }
  }
  componentWillReceiveProps(nextProps) {
    const { src: nextSrc } = nextProps
    if (nextSrc !== this.props.src) {
      this.resetProgress(() => {
        // If we're setting src=undefined, don't start the progress bar as we're
        // not actually loading a page
        if (nextSrc) {
          this.setProgressTimeout(this.startProgress, 100)
        }
      })
    }
  }
  componentWillUnmount() {
    this.clearProgressTimeout()
  }
  isHidden = () => {
    const { hidden, src } = this.props
    return !src || hidden
  }
  setProgressTimeout = (...args) => {
    this.progressTimer = setTimeout(...args)
  }
  clearProgressTimeout = () => {
    clearTimeout(this.progressTimer)
  }
  startProgress = () => {
    this.setState({ loadProgress: LOADING_START }, () => {
      this.setProgressTimeout(this.fudgeProgress, 500)
    })
  }
  fudgeProgress = () => {
    const { loadProgress } = this.state
    if (loadProgress < LOADING_FUDGE_LIMIT) {
      const delay = clamp(Math.random() * 1000, 350, 650)
      // Move progress ahead by 1.5% to 7.5%
      const moveProgress = clamp(Math.random() / 10, 0.02, 0.1)
      const nextProgress = lerp(moveProgress, loadProgress, LOADING_END)
      this.setState({ loadProgress: nextProgress }, () => {
        this.setProgressTimeout(this.fudgeProgress, delay)
      })
    }
  }
  endProgress = () => {
    this.clearProgressTimeout()
    this.setState({ loadProgress: LOADING_END }, () => {
      this.setProgressTimeout(this.resetProgress, 1000)
    })
  }
  resetProgress = (cb = noop) => {
    this.clearProgressTimeout()
    this.setState({ loadProgress: 0 }, cb)
  }
  handleOnLoad = (...args) => {
    const { onLoad } = this.props
    // As it turns out, setting src=undefined on an iframe also triggers the onLoad handler.
    // We avoid doing anything in that case as the iframe hasn't really loaded a page.
    if (this.props.src) {
      this.endProgress()
      if (typeof onLoad === 'function') {
        onLoad(...args)
      }
    }
  }
  render() {
    const { src, ...props } = this.props
    const { loadProgress } = this.state
    const show = !this.isHidden()
    const progressBar = show &&
      !!loadProgress && <AppLoadingProgressBar percent={loadProgress} />

    // Remove onLoad prop as we wrap it with our own
    delete props.onLoad

    return (
      <React.Fragment>
        {progressBar}
        <StyledIFrame
          frameBorder={0}
          onLoad={this.handleOnLoad}
          ref={iframe => {
            this.iframe = iframe
          }}
          sandbox={SANDBOX}
          style={{
            display: show ? 'initial' : 'none',
          }}
          src={src}
          {...props}
        />
      </React.Fragment>
    )
  }
}

const StyledIFrame = styled.iframe`
  display: block;
  height: 100%;
  width: 100%;
`

export default AppIFrame
